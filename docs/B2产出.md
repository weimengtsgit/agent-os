## 1️⃣ 本轮产出摘要（B2）

1. 明确 agno 在体系中的**推荐定位**：作为 **Runtime 引擎实现之一**（通过 Adapter 接入），而不是平台契约本身
2. 定义了 **PAL（Platform Abstraction Layer）最小抽象面**：Runtime / LLM / Tool / Memory / Trace&Event / Registry / Policy
3. 给出可直接开工的 **Python 接口骨架（抽象类 + 数据结构）**，并说明 agno Adapter 怎么实现
4. 划定“避免锁死”的 **红线**：业务 Agent 代码不得直接 import/use agno 核心对象
5. 给出 **契约测试（contract tests）**策略：确保 agno 升级不破坏平台
6. 给出下一轮（B3）输入要求：进入 **Spec-first 契约定义**（Agent/Tool/Run/Trace/Policy）

---

## 2️⃣ 可执行 TODO 清单（P0 / P1 / P2）

### P0（必须现在做，避免锁死）

1. 建立 `platform-core/pal/`，落地 PAL 抽象接口（Runtime/LLM/Tool/Memory/Trace）
2. 建立 `agent-runtime-agno/adapters/`，实现 agno Runtime Adapter（只在这一层依赖 agno）
3. 规定 **业务 Agent 只能依赖 `platform-sdk`**（或 `platform-core` 的公共包），CI 加“禁止直接依赖 agno”规则
4. 定义 Run 事件流（start/step/tool_call/tool_result/end/error/cancel）并在 Adapter 内发事件
5. 建立 contract tests：给定固定 Spec + 固定输入，验证事件序列与关键字段不变
6. 明确 Tool 统一入口：Tool 必须走 ToolExecutor（可加超时/重试/审计）

### P1（MVP 很快会需要）

7. 抽象 LLM Provider：统一 token/cost 统计口径，避免散落在各 Runtime
8. Memory/Context 抽象：先支持“会话历史 + 可选向量检索”，不绑定 agno 内置实现
9. TraceSink 抽象：先支持 JSON 导出，后续可 OTLP
10. Policy 抽象：先做 allowTools / maxTokens / dataScope 的最小集合
11. Registry 抽象：AgentSpec/ToolSpec 的注册与查询
12. 为 agent-ui 或自研 Console 提供只读查询接口（Run 列表、事件流）

### P2（后续但要预留）

13. 多 Runtime 并存（agno + 其他）：RuntimeRouter（按 AgentSpec 选择）
14. Prompt/Model 灰度发布：Spec 引用版本化资源（promptRef/modelRef）
15. 运行隔离：并发/限流/配额/取消传播
16. 统一审计：tool_call、human_review、policy_violation 全落事件

---

## 3️⃣ 关键接口 / 契约草案（PAL 最小可落地）

> 下面给的是“可直接写代码”的最小接口集：**先够用**，后续再扩展。

### 3.1 PAL 数据结构（Spec / Run / Event）

```python
from __future__ import annotations
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional, Protocol, Iterable, Literal

RunStatus = Literal["running", "completed", "failed", "canceled"]
EventType = Literal[
    "run_start", "run_step",
    "tool_call", "tool_result",
    "human_review_request", "human_review_result",
    "run_end", "run_error", "run_cancel"
]

@dataclass(frozen=True)
class AgentSpec:
    name: str
    version: str
    owner: str
    type: Literal["conversational", "workflow", "batch"]
    model: Dict[str, Any]          # provider/name/params
    prompt_ref: str
    tools: List[str]
    policies: Dict[str, Any] = field(default_factory=dict)
    runtime: Dict[str, Any] = field(default_factory=dict)  # runtime selection hints

@dataclass(frozen=True)
class ToolSpec:
    name: str
    inputs_schema: Dict[str, Any]
    outputs_schema: Dict[str, Any]
    timeout_ms: int = 3000
    retry: int = 0
    permissions: List[str] = field(default_factory=list)
    side_effects: bool = False

@dataclass(frozen=True)
class RunContext:
    run_id: str
    session_id: str
    agent: str
    actor: Dict[str, Any] = field(default_factory=dict)     # user/service identity
    metadata: Dict[str, Any] = field(default_factory=dict)  # request tags, tenant, etc.

@dataclass(frozen=True)
class RunEvent:
    run_id: str
    session_id: str
    agent: str
    event_type: EventType
    timestamp_iso: str
    payload: Dict[str, Any]
    trace_id: Optional[str] = None
```

---

### 3.2 PAL 核心接口（Runtime / Tool / LLM / Memory / Trace）

```python
class EventSink(Protocol):
    def emit(self, event: RunEvent) -> None: ...

class TraceSink(Protocol):
    def start_span(self, name: str, trace_id: str, attrs: Dict[str, Any]) -> str: ...
    def end_span(self, span_id: str, status: str, attrs: Dict[str, Any]) -> None: ...
    def record_metric(self, name: str, value: float, attrs: Dict[str, Any]) -> None: ...

class PolicyEngine(Protocol):
    def check_tool_allowed(self, agent_spec: AgentSpec, tool_name: str, actor: Dict[str, Any]) -> None: ...
    def check_limits(self, agent_spec: AgentSpec, usage: Dict[str, Any]) -> None: ...

class ToolExecutor(Protocol):
    def execute(self, tool_name: str, tool_input: Dict[str, Any], ctx: RunContext) -> Dict[str, Any]: ...

class MemoryStore(Protocol):
    def append_message(self, session_id: str, role: str, content: str, meta: Dict[str, Any]) -> None: ...
    def get_history(self, session_id: str, limit: int = 50) -> List[Dict[str, Any]]: ...
    def put_kv(self, session_id: str, key: str, value: Any) -> None: ...
    def get_kv(self, session_id: str, key: str) -> Any: ...

class LLMProvider(Protocol):
    def generate(self, *, messages: List[Dict[str, Any]], model: Dict[str, Any], trace_id: str) -> Dict[str, Any]:
        """
        Return: {"content": "...", "usage": {"prompt_tokens":..,"completion_tokens":..,"cost":..}, "raw": {...}}
        """
        ...

class AgentRuntime(Protocol):
    def run(self, agent_spec: AgentSpec, user_input: Dict[str, Any], ctx: RunContext) -> Iterable[RunEvent]: ...
    def cancel(self, run_id: str) -> None: ...
```

> ✅ **关键点**：平台层只认识这些接口，不认识 agno 对象。

---

### 3.3 agno Adapter 实现策略（轮廓）

```python
class AgnoRuntimeAdapter:
    def __init__(
        self,
        tool_exec: ToolExecutor,
        memory: MemoryStore,
        llm: LLMProvider,
        events: EventSink,
        tracer: TraceSink,
        policy: PolicyEngine,
    ):
        ...

    def run(self, agent_spec: AgentSpec, user_input: Dict[str, Any], ctx: RunContext):
        trace_id = ctx.metadata.get("trace_id") or f"trace-{ctx.run_id}"
        self.events.emit(RunEvent(..., event_type="run_start", trace_id=trace_id, payload={...}))

        # 1) 将 AgentSpec 映射为 agno Agent（仅在 adapter 内部）
        # 2) 注入 tool 回调：agno 调用 tool => 走 ToolExecutor => emit tool_call/tool_result
        # 3) 将 agno 的中间输出映射为 run_step 事件
        # 4) 收尾 emit run_end / run_error

        yield from self._bridge_events(...)
```

---

## 4️⃣ 目录结构 / 模块划分建议（PAL + agno adapter 可直接开工）

```text
agent-platform/
├── platform-core/
│   ├── pal/
│   │   ├── types.py              # AgentSpec/ToolSpec/RunEvent/RunContext
│   │   ├── runtime.py            # AgentRuntime interface
│   │   ├── tools.py              # ToolExecutor interface
│   │   ├── llm.py                # LLMProvider interface
│   │   ├── memory.py             # MemoryStore interface
│   │   ├── observability.py       # EventSink/TraceSink
│   │   └── policy.py             # PolicyEngine
│   ├── specs/
│   │   ├── schemas/              # JSON Schema / YAML schema (B3会细化)
│   │   └── validator.py
│   ├── registry/
│   │   ├── store.py              # Registry interface + impl
│   │   └── api.py                # HTTP/GRPC (后续)
│   └── sdk/
│       ├── agent_base.py          # 业务Agent开发用的基类/装饰器
│       └── cli.py                 # validate/spec/run-local
│
├── agent-runtime-agno/
│   ├── adapters/
│   │   ├── agno_runtime.py        # AgnoRuntimeAdapter
│   │   ├── agno_tool_bridge.py    # tool hook / callback bridge
│   │   └── agno_event_bridge.py   # agno output -> RunEvent mapping
│   └── tests/
│       ├── contract/
│       └── fixtures/
│
├── agents/
│   └── sample-agent/
│       ├── agent.yaml
│       ├── prompts/
│       └── tools/
│
└── console/
    └── (agent-ui or minimal web)
```

---

## 5️⃣ 里程碑与验收标准（可量化）

### M0：PAL 落地（3–5 天）

* [ ] `platform-core/pal` 接口齐全（Runtime/Tool/LLM/Memory/Event/Trace/Policy）
* [ ] 业务示例代码只依赖 `platform-core/sdk`，不依赖 agno

### M1：agno Adapter 跑通（1–2 周）

* [ ] 用 `AgentSpec` 启动并完成一次 Run
* [ ] 产生完整事件序列（start→step→end）
* [ ] Tool 调用必然产生 tool_call/tool_result 事件
* [ ] cancel(run_id) 生效且可观测

### M2：契约测试（1 周）

* [ ] contract test 固定输入输出：事件序列与关键字段稳定
* [ ] agno 升级（小版本）通过 contract tests 才允许合入

---

## 6️⃣ 风险与回滚方案（至少 3 条）

1. **风险：PAL 设计过度抽象，导致开发效率下降**

   * 信号：Adapter 实现“为了适配而适配”，业务写 Agent 变复杂
   * 回滚：PAL 只保留 MVP 必需面；高级能力（teams/workflows）先不抽象

2. **风险：业务团队绕过 PAL 直接用 agno 快速写 Agent**

   * 信号：出现 `import agno` 在 agents/ 目录
   * 回滚：CI 增加依赖扫描；SDK 里提供足够顺手的 API（让“走正道更容易”）

3. **风险：agno 的中间过程事件难以稳定映射**

   * 信号：不同 agent 输出结构差异大，event bridge 维护成本高
   * 回滚：MVP 只保证关键事件（run_start/tool_call/tool_result/run_end/run_error）；step 事件先降级为文本日志

4. **风险：token/cost 统计口径混乱**

   * 回滚：强制 LLMProvider 统一返回 usage；Adapter 只透传，不自己计算

---

## 7️⃣ 下一轮输入要求（B3）

请把你上一轮的输出不用再贴了（我这边已经按 B1/B2 的上下文推进），直接发：

> **B3：Spec-first 目标架构 + 关键契约（最重要的一轮）**

我下一轮会输出（至少 5 个）**可直接落地的契约**：

* Agent Spec（正式版）
* Tool Spec（正式版）
* Run Event Schema（正式版）
* Trace/Observation Schema
* Policy Spec
  并同时给出“目标架构组件清单 + 数据流 + 部署拓扑”。

如果你想再提速，在 B3 后面加一句：**“B3 + 契约用 JSON Schema 输出”**，我会直接给你可放进仓库的 schema 文件骨架。
